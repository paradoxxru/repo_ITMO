Точка входа - index.php

1) аутентификация: получить текущего пользователя со всеми правами доступа
require_once ("../app/user.php");
$user = new User();


2) роутинг: определить, какую страницу запрашивает пользователь и есть ли у него соответствующие права.

Для каждой типовой странницы будет свой класс.
	- CCartController.php  класс, отвечающий за формирования страницы с корзиной
	- CCatalogController.php  класс, отвечающий за формирование страницы каталога
	- CProductController.php  класс, отвечающий за формирование страницы конкретного товара
	- сделать! CSortController.php - отвечающий за формирование страници сортировок товара(по весу, цене, популярности)

Название запрашиваемого раздела "прилетит" в GET параметре.(этот параметр будет прописан в ссылках)
		//index.php?q=catalog
		//или q=cart
		//или q=product
		// или q=sortby
require_once ("../app/router/CRouter.php");
$controller = CRouter::getController(); - получаем объкт, одного из классов выше.
	В классе CRouter прописан метод getController, который по GET-параметру( q ) определяет какого класса будет $controller.
	То есть определяет какой раздел запрашивают. Если параметр q не задан, то дефолтным считается раздел catalog.

3) сформировать запрашиваемую страницу и отправить в браузер пользователю
 3.1) Если запрашивают catalog (то есть $controller = new CCatalogController() )
	
	$controller->setPermissions($user->getAllPermissions()); - устанавливаем разрешения пользователя исходя из аутентификации
			- доделать
	$controller->render(); - вызываем метод формирования раздела на странице.
	    В этом методе:
		a) из конфигурационного файла(базы данных) получаем все товары в виде массива(будет массив массивов)
			$parser = CConfParser::getInstance('../app/config/db_product.yaml');
				- метод getInstance по расширению файла определяет какого класса объект будет возвращен.
				  CYamlParser - класс(потомок CConfParser), умеющий работать с файлами с расширением .yaml(чтение/запись в эти файлы)
				  CTextConfParser - класс(потомок CConfParser), умеющий работать с файлами с расширением .txt(чтение/запись в эти файлы)
				  У нас получается $parser = new CYamlParser(); так как передали .yaml
			$parser->read(); - читаем из файла
				- здесь используется метод read() для объекта класса CYamlParser.
				Результатом чтения из файла будет заполненный массив $params(это поле есть у этого класса от родительского), где, 
				ключами будут каждая девятая строка из файла .yaml ('0', '1', ...'49'), а значениями будут ассоц. массивы, 
				состоящие из восьми элементов ( ["weight"]=>"4" , ["name"]=>"Подхуд над пер" , ["img"]=>"im5.svg" ). То есть массив params будет выглядеть:
				$params[2] - это ассоц. массив из восьми элементов
			$goods = $parser->getAllParams(); - формируем массив товаров.
				- метод getAllParams() возвращает весь массив $params - правильно ли что теперь обе переменные ссылаются на один массив???????
				
		b) определяем/задаем шаблон html страницы, которую нужно отразить(catalog.php - шаблон страницы каталога, 
		cart.php - шаблон страницы корзины, product.php - шаблон страницы конкретного продукта, в папке views\product 
		шаблоны отображения продукта в различных разделах страницы(продукт в каталоге, продукт в корзине, продукт подробно))
			$path_to_template = "../app/views/catalog.php"; - ЗАДАЛИ путь к шаблону руками
			
			include($path_to_template); - подключили соответствующий шаблон
			   В этом html шаблоне(../app/views/catalog.php):
				b.1) у ссылок заданы параметры, которые при нажатии попадут в $_GET массив, например:
					в сортировке по весу
				  <a id="WeightUp" href="/index.php?q=catalog&action=sort_up&sort_fieid=wieght">↑</a>
					в ссылке на корзину
				  <a href="/index.php?q=cart" id="Cart" data-action="open-cart">Корзина</a>
					- ДОДЕЛАТЬ
				b.2) в разделе Каталог ( <div class="catalog"> ) в цикле - foreach($goods as $id => $item)  (id-шниками будут ключи массива goods,
					это 0,1,2 и тд. А $item - будут массивами, например $goods[0]['category'] = 'Миг над' )
				  - проверяем GET параметры (action, field и тд)
				  - $product = new CFruitProduct($id); создаем объект класса CFruitProduct(который является потомком от CProduct)
					Если передали $id(не равный строке "random"), то формируется объект с "пустыми" полями(name = '', weight = 0, category = '', 
					img = '', cost = 0, description = '' и тд) и с полем id, равным переданному
				  - $product->fromArray($item); заполняем поля созданного объекта значениями из массива товаров  - передаем элемент массива goods
					(который ЯВЛЯЕТСЯ массивом), а в методе fromArray в цикле присваиваем полю объекта значение элемента ассоц.массива 
					ТО ЕСТЬ НА КАЖДОМ ШАГЕ ЦИКЛА мы создаем объект и присваиваем его полям значения из "соответствующего" ассоц.массива
				  - далее определяем/задаем какое представление html шаблона звять(то есть в каком разделе страницы
					(подробно о товаре, в корзине, в каталоге) выводить продукт)
					у нас этот шаг пропущен - мы "задали" вывод в раздел каталог
				  - выводим(НА ТОМ ЖЕ ШАГЕ ВЫВОДИМ ОДИН ОБЪЕКТ)
					$product->render('catalog'); метод render у этого объекта принимает параметр(какое представление взять) и выводит шаблон.
					(мы "задали" руками вывод в раздел каталог 'catalog'). В зависимости от того что передали будет выводиться определенный шаблон:
						public function render($view)
						{
							$path_to_view = "../app/views/"."/product/".$view.".php"; - определили шаблон
							include ($path_to_view); - подключили шаблон
						}
					В шаблоне 	../app/views/product/catalog.php определен шаблон вывода ОДНОГО объекта(товара) в раздел <div class="catalog__item">
						<div class="catalog__item">
							<span class="catalog__item-name">
								<?php
								 echo $this->name;
								?>
							</span>
							<img class="catalog__item-preview" src="assets/images/<?php echo $this->img; ?>" alt="">
							<span class="catalog__item-cost"><?php echo $this->cost; ?></span>
							<a href="/index.php?q=product&id=<?php echo $this->id; ?>">Подробнее</a>						
							<a href="/index.php?q=catalog&id=<?php echo $this->id; ?>&action=addtocatr">В корзину</a>		- Проверить get параметры
						</div>
						
					
Вопросы:
1)файл CCatalogController.php - require_once('../app/product/CFruitProduct.php'); 
почему подключаем только здесь, а в CCartController не подключаем (а если 1-я запрашиваемая страница будет Корзина) ???????????

2)файл CSortController.php - в ф-ции private function getSortRule() 29-я строка		

3)файл CFilterController.php - в ф-ции public function render() 13-я строка (НУЖНО ли проверять на "непустые значения $_GET")

4) порядок подключения файлов php - верно ли утверждение что если в начале index.php подключен файл и создан объект, то объект будет жить до конца кода,
Точка входа index.php и какие бы нибыли get-параметры код всегда начнет выполняться с index.php
Где делать $login= $pass= $user->login()
Если на странице формы, то залогинились, записали инфу в объект user ... и в $_SESSION ??? и код отработал, объект удален и инфа только в сессии!!!
Зачем тогда заполнять поля обекта(например залогинен ли($is_auth)) если на "другой" странице будем определять по сессии

public function __construct() { // для идентификации пользователя на других страницах сайта???? что это значит?

5)корректно ли обращаться к классу без создания объекта?
CInfoSession::setInfoSession();
CInfoSession::getInfoSession($goods);
echo "( ". CInfoSession::$col." шт. На сумму: ".CInfoSession::$sum." )";

Вопрос по подключению файлов. Как я понимаю файлы все в итоге собираются в один документ(index.php, возвращающий html), из-за этого и пути подключения относительно index.php.
Точка входа у нас index.php. Соответственно как только браузер запрашивает страницу начинает отрабатывать код. Сначала в index.php мы подключаем класс и создаем объект
require_once ("../app/user.php");
$user = new User();
затем определяется контроллер и вызываем его рендер. В рендере читаем из файла и создаем массив $goods и подключаем файл catalog.php
И вот в файле catalog.php массив $goods доступен, а вот обратиться к методу класса user($user->login()) нельзя - ошибка. 
Только подключая файл с классом в файл catalog.php и создавая объект там.
Поскажите пожалуйста почему так происходит?

Если это из-за области видимости(так как это в рендере), то если мы будем создавать объект "внутри" редера, то получиться два объекта - 
один "внутри", второй "снаружи"... или две ссылки на один объект? Зачем создавать объект до "создания" контроллера? может создавать его в рендере?
Получается что объект надо создавать на каждой подобной странице catr.php, product.php и тд?

Может быть в каждый контроллер добавить парсер для файла(yaml) где хранятся данные о пользователях(логи, кеши паролей, адреса, почты и тд)
и сщздавать массив данных о пользователях?

